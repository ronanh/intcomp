// This file is generated, do not modify directly
// Use 'go generate' to regenerate.

package intcomp

import "unsafe"

{{- $dp := .}}

// AppendGroup_{{$dp.Typename}} Binary packing of one block of `in`, starting from `initoffset`
// to out. Differential coding is applied first.
// Caller must give the proper `bitlen` of the block
func appendGroup_{{$dp.Typename}}[T uint{{$dp.Bits}}|int{{$dp.Bits}}](dst []uint{{$dp.Bits}}, in *[{{$dp.Bits}}]T, initoffset T{{$dp.NtzExtraParam}}, bitlen int) []uint{{$dp.Bits}} {
	switch {{$dp.BitlenExpr}} - 1 {
{{- range $dpn := $dp.Dpn }}
{{- if ne $dpn.N 0 }}
	case {{$dpn.N}} - 1:
{{- if $dp.WithNtz }}
		if ntz > 0 {
			return appendGroup{{$dp.Bits}}_ntz_{{$dpn.N}}(dst, in, initoffset, ntz)
		}
{{- end }}
		return appendGroup{{$dp.Bits}}_{{$dpn.N}}(dst, in, initoffset)
{{- end }}
{{- end }}
	case {{$dp.Bits}} - 1:
		same := (*[{{$dp.Bits}}]uint{{$dp.Bits}})(unsafe.Pointer(in))
		return append(dst, same[:]...)
	}
	return dst
}

// deltaUnpack_{{$dp.Typename}} Decoding operation for DeltaPack_{{$dp.Typename}}
func deltaUnpack_{{$dp.Typename}}[T uint{{$dp.Bits}}|int{{$dp.Bits}}](initoffset T, in []uint{{$dp.Bits}}, out []T{{$dp.NtzExtraParam}}, bitlen int) {
	switch {{$dp.BitlenExpr}} {
{{- range $dpn := $dp.Dpn }}
	case {{$dpn.N}}:
{{- if $dp.WithNtz }}
		if ntz > 0 {
			deltaunpack{{$dp.Bits}}_ntz_{{$dpn.N}}(initoffset, (*[{{$dpn.N}}]uint{{$dp.Bits}})(in), (*[{{$dp.Bits}}]T)(out), ntz)
			break
		}
{{- end }}
		deltaunpack{{$dp.Bits}}_{{$dpn.N}}(initoffset, (*[{{$dpn.N}}]uint{{$dp.Bits}})(in), (*[{{$dp.Bits}}]T)(out))
{{- end }}
	case {{$dp.Bits}}:
		*(*[{{$dp.Bits}}]T)(out) = *(*[{{$dp.Bits}}]T)(unsafe.Pointer((*[{{$dp.Bits}}]uint{{$dp.Bits}})(in)))
	default:
		panic("unsupported bitlen")
	}
}

{{- if not $dp.Unsigned }}
{{- range $dpn := $dp.Dpn }}
{{- if ne $dpn.N 0 }}

func appendGroup{{$dp.Bits}}_{{$dpn.N}}[T uint{{$dp.Bits}}|int{{$dp.Bits}}](dst []uint{{$dp.Bits}}, in *[{{$dp.Bits}}]T, initoffset T) []uint{{$dp.Bits}} {
	return append(dst
{{- range $dpnb := $dpn.Dpnb }},
		uint{{$dp.Bits}}(
{{- range $line := $dpnb.PackLines }}
{{- $line}}
{{- end }})
{{- end }})
}

{{- if $dp.WithNtz }}
func appendGroup{{$dp.Bits}}_ntz_{{$dpn.N}}[T uint{{$dp.Bits}}|int{{$dp.Bits}}](dst []uint{{$dp.Bits}}, in *[{{$dp.Bits}}]T, initoffset T, ntz int) []uint{{$dp.Bits}} {
	ntz = ntz&({{$dp.Bits}}-1) //nolint:ineffassign,staticcheck
	return append(dst
{{- range $dpnb := $dpn.Dpnb }},
		uint{{$dp.Bits}}(
{{- range $line := $dpnb.PackLinesNtz }}
{{- $line}}
{{- end }})
{{- end }})
}

{{- end }}
{{- end }}
{{- end }}
{{- end }}

{{- if not $dp.Unsigned }}
{{- range $dpn := $dp.Dpn }}

func deltaunpack{{$dp.Bits}}_{{$dpn.N}}[T uint{{$dp.Bits}}|int{{$dp.Bits}}](initoffset T, in *[{{$dpn.N}}]uint{{$dp.Bits}}, out *[{{$dp.Bits}}]T) {
{{- range $dunb := $dpn.Dunb }}
	out[{{$dunb.I}}] = {{$dunb.UnpackLine}}
{{- end }}
}

{{- if $dp.WithNtz }}
func deltaunpack{{$dp.Bits}}_ntz_{{$dpn.N}}[T uint{{$dp.Bits}}|int{{$dp.Bits}}](initoffset T, in *[{{$dpn.N}}]uint{{$dp.Bits}}, out *[{{$dp.Bits}}]T, ntz int) {
	ntz = ntz&({{$dp.Bits}}-1)  //nolint:ineffassign,staticcheck
{{- range $dunb := $dpn.Dunb }}
	out[{{$dunb.I}}] = {{$dunb.UnpackLineNtz}}
{{- end }}
}

{{- end }}
{{- end }}
{{- end }}

// --- zigzag

// AppendGroupZigZag_{{$dp.Typename}} Binary packing of one block of `in`, starting from `initoffset`
// to out. Differential coding is applied first, the difference is zigzag encoded.
//  Caller must give the proper `bitlen` of the block
func appendGroupZigZag_{{$dp.Typename}}(dst []uint{{$dp.Bits}}, in *[{{$dp.Bits}}]{{$dp.Typename}}, initoffset {{$dp.Typename}}{{$dp.NtzExtraParam}}, bitlen int) []uint{{$dp.Bits}} {
	switch {{$dp.BitlenExpr}} - 1 {
{{- range $dpn := $dp.Dpn }}
{{- if ne $dpn.N 0 }}
	case {{$dpn.N}} - 1:
{{- if $dp.WithNtz }}
		if ntz > 0 {
			return appendGroupZigZag{{$dp.Bits}}_ntz_{{$dpn.N}}(dst, in, initoffset, ntz)
		}
{{- end }}
		return appendGroupZigZag{{$dp.Bits}}_{{$dpn.N}}(dst, in, initoffset)
{{- end }}
{{- end }}
	case {{$dp.Bits}} - 1:
		same := (*[{{$dp.Bits}}]uint{{$dp.Bits}})(unsafe.Pointer(in))
		return append(dst, same[:]...)
	}
	return dst
}

// deltaUnpackZigzag_{{$dp.Typename}} Decoding operation for DeltaPackZigzag_{{$dp.Typename}}
func deltaUnpackZigzag_{{$dp.Typename}}(initoffset {{$dp.Typename}}, in []uint{{$dp.Bits}}, out []{{$dp.Typename}}{{$dp.NtzExtraParam}}, bitlen int) {
	switch {{$dp.BitlenExpr}} {
{{- range $dpn := $dp.Dpn }}
	case {{$dpn.N}}:
{{- if $dp.WithNtz }}
		if ntz > 0 {
			deltaunpackzigzag{{$dp.Bits}}_ntz_{{$dpn.N}}(initoffset, (*[{{$dpn.N}}]uint{{$dp.Bits}})(in), (*[{{$dp.Bits}}]{{$dp.Typename}})(out), ntz)
			break
		}
{{- end }}
		deltaunpackzigzag{{$dp.Bits}}_{{$dpn.N}}(initoffset, (*[{{$dpn.N}}]uint{{$dp.Bits}})(in), (*[{{$dp.Bits}}]{{$dp.Typename}})(out))
{{- end }}
	case {{$dp.Bits}}:
		*(*[{{$dp.Bits}}]{{$dp.Typename}})(out) = *(*[{{$dp.Bits}}]{{$dp.Typename}})(unsafe.Pointer((*[{{$dp.Bits}}]uint{{$dp.Bits}})(in)))
	default:
		panic("unsupported bitlen")
	}
}

{{- if not $dp.Unsigned }}
{{- range $dpn := $dp.Dpn }}
{{- if ne $dpn.N 0 }}

func appendGroupZigZag{{$dp.Bits}}_{{$dpn.N}}[T uint{{$dp.Bits}}|int{{$dp.Bits}}](dst []uint{{$dp.Bits}}, in *[{{$dp.Bits}}]T, initoffset T) []uint{{$dp.Bits}} {
	return append(dst
{{- range $dpnb := $dpn.Dpnb }},
		uint{{$dp.Bits}}(
{{- range $line := $dpnb.PackLinesZigZag }}
{{- $line}}
{{- end }})
{{- end }})
}

{{- if $dp.WithNtz }}
func appendGroupZigZag{{$dp.Bits}}_ntz_{{$dpn.N}}[T uint{{$dp.Bits}}|int{{$dp.Bits}}](dst []uint{{$dp.Bits}}, in *[{{$dp.Bits}}]T, initoffset T, ntz int) []uint{{$dp.Bits}} {
{{- if $dp.WithNtz }}
	ntz = ntz&({{$dp.Bits}}-1) //nolint:ineffassign,staticcheck
{{- end }}
	return append(dst
{{- range $dpnb := $dpn.Dpnb }},
		uint{{$dp.Bits}}(
{{- range $line := $dpnb.PackLinesZigZagNtz }}
{{- $line}}
{{- end }})
{{- end }})
}

{{- end }}
{{- end }}
{{- end }}
{{- end }}

{{- if not $dp.Unsigned }}
{{- range $dpn := $dp.Dpn }}

func deltaunpackzigzag{{$dp.Bits}}_{{$dpn.N}}[T uint{{$dp.Bits}}|int{{$dp.Bits}}](initoffset T, in *[{{$dpn.N}}]uint{{$dp.Bits}}, out *[{{$dp.Bits}}]T) {
{{- range $dunb := $dpn.Dunb }}
	out[{{$dunb.I}}] = {{$dunb.UnpackLineZigZag}}
{{- end }}
}

{{- if $dp.WithNtz }}
func deltaunpackzigzag{{$dp.Bits}}_ntz_{{$dpn.N}}[T uint{{$dp.Bits}}|int{{$dp.Bits}}](initoffset T, in *[{{$dpn.N}}]uint{{$dp.Bits}}, out *[{{$dp.Bits}}]T, ntz int) {
	ntz = ntz&({{$dp.Bits}}-1) //nolint:ineffassign,staticcheck
{{- range $dunb := $dpn.Dunb }}
	out[{{$dunb.I}}] = {{$dunb.UnpackLineZigZagNtz}}
{{- end }}
}

{{- end }}
{{- end }}
{{- end }}
